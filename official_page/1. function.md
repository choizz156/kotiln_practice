# 함수

Kotlin에서 함수는 `fun` 키워드를 사용하여 선언됩니다:

```kotlin
fun double(x: Int): Int { return 2 * x }
```

## 1. 함수 사용

함수를 호출하는 방식은 일반적인 방식입니다:

```kotlin
val result = double(2)
```

멤버 함수를 호출할 때는 점(dot) 표기법을 사용합니다:

```kotlin
Stream().read()  // 클래스 Stream의 인스턴스를 생성하고 read()를 호출
```

### 1.1 매개변수

함수의 매개변수는 `이름: 타입` 형태로 정의됩니다. 매개변수들은 쉼표로 구분하며, 각 매개변수는 명시적으로 타입이 지정되어야 합니다:

```kotlin
fun powerOf(number: Int, exponent: Int): Int { /*…*/ }
```

함수 매개변수 선언 시 **후행 쉼표(trailing comma)** 를 사용할 수 있습니다:

```kotlin
fun powerOf(
    number: Int,
    exponent: Int, // trailing comma 가능
) { /*…*/ }
```

### 1.2 기본값이 있는 매개변수

함수 매개변수는 기본값(default value)을 가질 수 있으며, 해당 인수를 생략할 경우 기본값이 사용됩니다. 이 기능은 오버로드(overload)의 수를 줄여줍니다:

```kotlin
fun read(b: ByteArray, off: Int = 0, len: Int = b.size) { /*…*/ }
```

이처럼 기본값이 설정된 매개변수는 선택 매개변수(optional parameter)라고도 부릅니다.
 기본값은 타입 뒤에 `=`를 붙여 설정합니다.
 오버라이딩(overriding) 메서드는 항상 기반 메서드(base method)의 기본 매개변수 값을 사용해야 합니다. 기본값이 있는 메서드를 오버라이드할 때는 서명(signature)에서 기본값을 생략해야 합니다:

```kotlin
open class A { open fun foo(i: Int = 10) { /*…*/ } }
class B : A() { override fun foo(i: Int) { /*…*/ } // 기본값 생략
}
```

만약 기본값이 있는 매개변수가 기본값이 없는 매개변수보다 먼저 온다면, 기본값을 사용하려면 **명명 인자(named argument)** 방식으로 함수 호출 시 인자의 이름을 지정해야 합니다:

```kotlin
fun foo(bar: Int = 0, baz: Int) { /*…*/ }
foo(baz = 1) // bar = 0 기본값 사용
```

마지막 매개변수 뒤에 함수 타입(function type)의 매개변수가 있고, 앞쪽 매개변수들이 모두 기본값을 가진다면, 해당 람다(lambda) 인자는 **괄호 밖**으로 전달할 수 있습니다:

```kotlin
fun foo(
    bar: Int = 0,
    baz: Int = 1,
    qux: () -> Unit,
) { /*…*/ }

// 호출 예시:
foo(1) { println("hello") }                // baz = 1 기본값 사용
foo(qux = { println("hello") })          // bar = 0, baz = 1 기본값 사용
foo { println("hello") }                 // bar = 0, baz = 1 기본값 사용
```

### 1.3 명명 인자 (Named arguments)

함수를 호출할 때 하나 이상 인자의 이름을 지정하여 전달할 수 있습니다. 이 방식은 특히 매개변수가 많거나 `Boolean` 혹은 `null` 값 등 뜻이 불명확한 인자를 전달할 때 유용합니다.
 명명 인자를 사용할 경우 인자들의 순서를 자유롭게 바꿀 수 있습니다. 기본값이 있는 인자는 생략할 수도 있습니다.
 예를 들어 다음과 같은 함수가 있다고 할 때:

```kotlin
fun reformat(
    str: String,
    normalizeCase: Boolean = true,
    upperCaseFirstLetter: Boolean = true,
    divideByCamelHumps: Boolean = false,
    wordSeparator: Char = ' ',
) { /*…*/ }
```

이 함수를 호출할 때는 다음과 같이 할 수 있습니다:

```kotlin
reformat("String!", false, upperCaseFirstLetter = false, divideByCamelHumps = true, '_')
```

기본값이 있는 모든 인자를 생략할 수도 있습니다:

```kotlin
reformat("This is a long String!")
```

기본값이 있는 일부 인자만 생략하고 특정 인자만 지정할 수도 있지만, **처음 생략된 인자 뒤의 인자들부터는 반드시 이름을 지정해야 합니다**:

```kotlin
reformat("This is a short String!", upperCaseFirstLetter = false, wordSeparator = '_')
```

`vararg` (가변 인자) 매개변수를 사용할 때도 이름을 지정하여 전달할 수 있으며, 이때는 배열 앞에 스프레드 연산자(`*`)를 붙입니다:

```kotlin
fun foo(vararg strings: String) { /*…*/ }
foo(strings = *arrayOf("a", "b", "c"))
```

Java 함수(JVM 상)의 경우, 함수 파라미터의 이름이 항상 바이트코드에 보존되지 않기 때문에 **명명 인자 문법(named argument syntax)** 은 사용할 수 없습니다.

### 1.4 `Unit`을 반환하는 함수

함수가 유의미한 반환값(return value)을 가지지 않는 경우, 반환 타입을 `Unit`으로 선언할 수 있습니다. `Unit`은 단 하나의 값만 가지는 타입이며(`Unit` 값 역시 `Unit`), 이 값은 명시적으로 반환할 필요가 없습니다:

```kotlin
fun printHello(name: String?): Unit {
    if (name != null) println("Hello $name")
    else println("Hi there!")
    // `return Unit` 또는 `return` 은 선택적(optional)
}
```

반환 타입이 `Unit`일 경우, 반환 타입 선언은 생략할 수도 있습니다. 위 코드는 다음과 같이 간단히 쓸 수 있습니다:

```kotlin
fun printHello(name: String?) {
    /*…*/
}
```

### 1.5 단일 표현식 함수 (Single-expression functions)

함수 본문(body)이 단 하나의 표현식으로 구성되어 있다면, 중괄호 `{}`를 생략하고 `=` 기호 뒤에 표현식을 바로 지정할 수 있습니다:

```kotlin
fun double(x: Int): Int = x * 2
```

컴파일러가 반환 타입을 추론할 수 있다면, 명시적인 반환 타입 선언도 **옵션**입니다:

```kotlin
fun double(x: Int) = x * 2
```

### 1.6 명시적 반환 타입

블록 본문(block body)을 가지는 함수의 경우, 반환 타입을 반드시 명시적으로 선언해야 합니다. 다만 반환 타입이 `Unit`이라면 반환 타입 선언이 옵션입니다.
 Kotlin은 블록 형태의 함수 본문에 대해서는 반환 타입을 추론하지 않습니다. 그 이유는 이런 함수들이 복잡한 제어 흐름(control flow)을 가질 수 있으며, 반환 타입이 명확하지 않을 수 있기 때문입니다.

### 가변 인자 (varargs)

함수의 매개변수(보통 마지막 매개변수)를 `vararg` 수식어(modifier)로 표시할 수 있습니다:

```kotlin
fun <T> asList(vararg ts: T): List<T> {
    val result = ArrayList<T>()
    for (t in ts) // ts는 배열(Array)입니다.
        result.add(t)
    return result
}
```

이 경우, 함수 호출 시 가변 인자에 대해 여러 개의 인자를 전달할 수 있습니다:

```kotlin
val list = asList(1, 2, 3)
```

함수 내부에서 `vararg` 매개변수 `ts`는 `Array<out T>` 타입의 배열로 보입니다.
 `vararg` 매개변수는 하나만 허용됩니다. 만약 `vararg` 매개변수가 매개변수 리스트의 마지막이 아니라면, 그 뒤에 오는 매개변수들은 **명명 인자(named argument)** 방식으로 전달되거나, 함수 타입이면 괄호 밖 람다(lambda)로 전달해야 합니다.
 함수를 호출할 때 이미 배열이 있다면, 그 배열 앞에 스프레드 연산자(`*`)를 붙여 내용을 전달할 수 있습니다:

```kotlin
val a = arrayOf(1, 2, 3)
val list = asList(-1, 0, *a, 4)
```

만약 원시 타입 배열(예: `IntArray`)을 `vararg`로 전달하고자 한다면, `toTypedArray()` 함수를 이용하여 일반 배열(typed array)로 변환해야 합니다:

```kotlin
val a = intArrayOf(1, 2, 3) // IntArray는 원시 타입 배열입니다.
val list = asList(-1, 0, *a.toTypedArray(), 4)
```

### 1.7 중위 표기법(Infix notation)

`infix` 키워드가 붙은 함수는 점(dot)과 괄호를 생략하고 중위 표기법으로 호출할 수 있습니다. 중위 함수가 되기 위한 조건은 다음과 같습니다:

- 멤버 함수(member function)이거나 **확장 함수(extension function)** 여야 합니다.
- 하나의 매개변수만 가져야 합니다.
- 그 매개변수는 `vararg`가 아니어야 하며, 기본값(default value)을 가져서는 안 됩니다.
   예:

```kotlin
infix fun Int.shl(x: Int): Int { … }
1 shl 2  // 위 함수 호출과 동일
```

중위 함수 호출은 산술 연산자(arithmetic operators), 타입 캐스트(type casts), `rangeTo` 연산자보다 우선순위가 낮습니다. 다음 표현식들은 동일합니다:

- `1 shl 2 + 3` 은 `1 shl (2 + 3)` 과 동일
- `0 until n * 2` 은 `0 until (n * 2)` 와 동일
- `xs union ys as Set<*>` 은 `xs union (ys as Set<*>)` 와 동일

반면, 중위 함수 호출은 불리언 연산자(`&&`, `||`), `is` 체크, `in` 체크 등보다는 우선순위가 높습니다. 예:

- `a && b xor c` 은 `a && (b xor c)` 와 동일
- `a xor b in c` 은 `(a xor b) in c` 와 동일

중위 함수는 항상 **리시버(receiver)** 와 매개변수가 명시되어야 합니다. 현재 리시버에서 중위 표기법으로 메서드를 호출할 때는 `this`를 명시적으로 사용해야 합니다. 이는 파싱(구문 분석, parsing)의 모호성을 없애기 위한 요구사항입니다. 예를 들어:

```kotlin
class MyStringCollection {
    infix fun add(s: String) { /*…*/ }
    fun build() {
        this add "abc"    // 올바름
        add("abc")        // 올바름
        // add "abc"      // 잘못됨: 리시버가 명시되어야 함
    }
}
```

## 2. 함수의 스코프 (Function scope)

Kotlin 함수는 파일의 최상위(top level)에 선언될 수 있으므로, Java, C#, Scala 같은 언어에서처럼 함수를 담을 클래스를 반드시 생성할 필요가 없습니다. ([Kotlin](https://kotlinlang.org/docs/functions.html))
 최상위 함수 외에도, Kotlin에서는 **지역 함수(local functions)**, **멤버 함수(member functions)**, **확장 함수(extension functions)** 등을 선언할 수 있습니다.

### 2.1 지역 함수 (Local functions)

Kotlin은 다른 함수 내부에 함수를 선언할 수 있는 지역 함수를 지원합니다:

```kotlin
fun dfs(graph: Graph) {
    fun dfs(current: Vertex, visited: MutableSet<Vertex>) {
        if (!visited.add(current)) return
        for (v in current.neighbors) dfs(v, visited)
    }
    dfs(graph.vertices[0], HashSet())
}
```

지역 함수는 외부 함수의 로컬 변수(local variable)에 접근할 수 있습니다(즉, 클로저(closure)로 작동할 수 있습니다). 예를 들어:

```kotlin
fun dfs(graph: Graph) {
    val visited = HashSet<Vertex>()
    fun dfs(current: Vertex) {
        if (!visited.add(current)) return
        for (v in current.neighbors) dfs(v)
    }
    dfs(graph.vertices[0])
}
```

### 2.3 멤버 함수 (Member functions)

멤버 함수란 클래스나 객체 내부에 정의된 함수를 의미합니다:

```kotlin
class Sample {
    fun foo() { print("Foo") }
}
```

멤버 함수 호출은 점(dot) 표기법을 사용합니다:

```kotlin
Sample().foo()  // Sample 클래스의 인스턴스를 생성하고 foo 호출
```

클래스 및 멤버 오버라이딩(overriding)에 관한 보다 자세한 내용은 “Classes” 및 “Inheritance” 문서를 참고하세요. ([Kotlin](https://kotlinlang.org/docs/functions.html))

## 제네릭 함수 (Generic functions)

함수는 꺾쇠괄호(angle brackets) 안에 제네릭 타입 매개변수(generic type parameter)를 지정할 수 있습니다:

```kotlin
fun <T> singletonList(item: T): List<T> { /*…*/ }
```

제네릭 함수에 대한 더 자세한 내용은 “Generics” 문서를 참고하세요. ([Kotlin](https://kotlinlang.org/docs/functions.html))

## 3. 꼬리 재귀 함수 (Tail-recursive functions)

Kotlin에서는 꼬리 재귀(tail recursion) 방식을 지원합니다. 일반적으로 루프(loop)를 사용했을 알고리즘이라도, 재귀 함수 형태로 작성하면서 스택 오버플로우(stack overflow)의 위험 없이 구현할 수 있습니다.
 함수가 `tailrec` 수식어(modifier)를 가지고 있고 요구 조건을 만족한다면, 컴파일러가 재귀 호출을 반복문(loop) 버전으로 최적화합니다:

```kotlin
val eps = 1E-10 // “충분히 좋음”, 10^-15도 가능
tailrec fun findFixPoint(x: Double = 1.0): Double =
    if (Math.abs(x - Math.cos(x)) < eps) x
    else findFixPoint(Math.cos(x))
```

이 코드는 코사인 함수(cosine)의 고정점(fixpoint)을 구합니다. 1.0에서 시작하여 반복해서 `Math.cos`를 호출하다가 결과가 더 이상 변하지 않을 때까지 계속하며, 그 값은 약 0.7390851332151611입니다. ([Kotlin](https://kotlinlang.org/docs/functions.html))
 이 코드는 전통적인 루프 스타일로 다음과 같이 구현 가능하였습니다:

```kotlin
val eps = 1E-10 // “충분히 좋음”
private fun findFixPoint(): Double {
    var x = 1.0
    while (true) {
        val y = Math.cos(x)
        if (Math.abs(x - y) < eps) return x
        x = Math.cos(x)
    }
}
```

`tailrec` 수식어를 사용하려면 함수가 마지막 연산으로 자기 자신을 호출해야 하며, `try` / `catch` / `finally` 블록 안에 있거나, 오픈(open) 함수(open functions)처럼 재정의 가능(overridable)인 경우에는 꼬리 재귀 최적화가 지원되지 않습니다. 현재 Kotlin의 JVM 및 Kotlin/Native에서 꼬리 재귀가 지원됩니다. ([Kotlin](https://kotlinlang.org/docs/functions.html))

### 참고

- 인라인 함수(Inline functions)
- 확장 함수(Extension functions)
- 고차 함수와 람다(Higher-order functions and lambdas) ([Kotlin](https://kotlinlang.org/docs/functions.html))
